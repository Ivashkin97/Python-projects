class SchoolMember:
	'''Представляет любого человека в школе.'''
	def __init__(self, name, age):
		self.name = name
		self.age = age
		print('(Создан SchoolMember: {0})'.format(self.name))
	def tell(self):
	'''Вывести информацию'''
		print('Имя:"{0}" возраст: "{1}"'.format(self.name, self.age), end=" ")

class Teacher(SchoolMember):
	'''Представляет преподавателя.'''
	def __init__(self, name, age, salary):
		schoolMember.__init__(self, name, age)
		self.salary = salary
		print('(Создан Teacher: {0})'.format(self.name))

	def tell(self):
		SchoolMember.tell(self)
		print('Зарплата: "{0:d}"'.format(self.salary))

class Student(SchoolMember):
	'''Представляет студента.'''
	def __init__(self, name, age, marks):
		SchoolMember.__init__(self, name, age)
		self.marks = marks
		print('(Создан Student: {0})'.format(self.name))

	def tell(self):
		SchoolMember.tell(self)
		print('Оценки: "{0:d}"'.format(self.marks))

t = Teacher('Mrs. Shrividya', 40, 30000)
s = Student('Swaroop', 25, 75)

print() #печатает пустую строку

members = [t,s]
for member in members:
    member.tell() #работает как для преподавателя, так и для студента

input("\n\nНажмите Enter, чтобы выйти.")

#Одно из главных достоинств объектно-ориентированного программирования заключается в многократном использовании одного и того же кода, и один из способов
#этого достичь - при помощи механизма наследования. Легче всего представить себе наследование в виде отношения между классами как тип и подтип.

#Представим, что нам нужно написать программу, которая отслеживает информацию о преподавателях и студентах в колледже. У них есть некоторые общие 
#характеристики: имя, возраст и адрес. Есть также и специфические характеристики, такие как зарплата, курсы и отпуск для преподавателей, а также оценки и
#оплата за обучение для студентов.

#Можно создать для них независимые классы и работать с ними, но тогда добавление какой-либо новой общей характеристики потребует добавления её к каждому 
#из этих независимых классов в отдельности, что делает программу неповоротливой.

#Лучше создать общий класс с именем SchoolMember, а затем сделать так, чтобы классы преподавателя и студента наследовали этот класс, т.е., чтобы они стали
#подтипами этого типа(класса), после чего добавить любые специфические характеристики к этим подтипам.

#У такого подхода есть множество достоинств. Если мы добавим/изменим какую-либо функциональность в SchoolMember, это автоматически отобразится и во всех 
#подтипах. Например, мы можем добавить новое поле удостоверения для преподавателей и студентов, просто добавив его к классу SchoolMember. С другой стороны,
#изменения в подтипах никак не влияют на другие подтипы. Еще одно достоинство состоит в том, что обращаться к объекту преподавателя или студента можно как к
#объекту SchoolMember, что может быть полезно в ряде случаев, например, для подсчёта количества человек в школе. Когда подтип может быть подставлен в любом
#месте, где ожидается родительский тип, т.е. объект считается экземпляром родительского класса, это называется полиморфизмом.

#Заметьте также, что код родительского класса используется многократно, и нет необходимости копировать его во все классы, как пришлось бы в случае 
#использования независимых классов.

#Класс SchoolMember в этой ситуации называют базовым классом или надклассом. Классы Teacher и Student называют производными классами или подклассами