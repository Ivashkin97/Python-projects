#Исключения возникают тогда, когда в программе возникает некоторая исключительная ситуация. Например, к чему приведёт попытка чтения несуществующего файла?
#Или если файл был случайно удален, пока программа работала? Такие ситуации обрабатываются при помощи исключений. Это касается и программ, содержащих
#недействительные команды. В этом случае Python поднимает руки и сообщает, что обнаружил ошибку

#Ошибки
#Рассмотрим простой вызов функции print. Что, если мы ошибочно напишем print как Print? 
#Обратите внимание на заглавную букву. В этом случае Python поднимает синтаксическую ошибку
#>>>Print('Привет, Мир!')
#Traceback (most recent call last):
#    File "<pyshell#0>", line 1, in <module>
#    	Print('Привет, Мир!')
#NameError: name 'Print' is not defined
#>>>print('Привет, Мир!')
#Привет, Мир!

#Исключения
#Попытаемся считать что-либо от пользователя. Нажмите Ctrl + Z в Windows и посмотрите, что произойдет
#>>>s = input('Введите что-нибудь-->')
#Введите что-нибудь-->
#Traceback (most recent call last):
#    File "<pyshell#2>", line 1, in <module>
#	s = input('Введите что-нибудь-->')
#EOFError: EOF when reading a line

#Python поднимает ошибку с именем EOFError, что означает, что он обнаружил символ конца файла (который вводится при помощи Ctrl - D) там, где не ожидал

#Обработка исключений
#Обрабатывать исключения можно при помощи оператора try..expert. При этом все обычные команды помещаются внутрь try-блока, а все обработчики исключений - в
#except-блок
#
#try:
#	text = input('Введите что-нибудь-->')
#except EOFError:
#	print('Ну зачем вы сделали мне EOF?')
#except KeyboardInterrupt:
#	print('Вы отменили операцию.')
#else:
#	print('Вы ввели {0}'.format(text))

#Вызов исключения
#Исключение можно поднять при помощи оператора raise, передав ему имя ошибки/исключения, а также объект исключения, который нужно выбросить
#Вызываемая ошибка или исключение должна быть классом, который прямо или непрямо является производным от класса Exception
#
#class ShortInputException(Exception):
#	'''Пользовательский класс исключения'''
#	def __init__(self, length, atleast):
#		Exception.__init__(self)
#		self.length = length
#		self.atleast = atleast
#
#try:
#	text = input('Введите что-нибудь-->')
#	if len(text) < 3:
#		raise ShortInputException(len(text), 3)
#	#Здесь может происходить обычная работа
#except EOFError:
#	print('Ну зачем вы сделали мне EOF?')
#except ShortInputException as ex:
#	print('ShortInputException: Длина введённой строки -- {0}; \
#		ожидалось, как минимум, {1}'.format(ex.length, ex.atleast))
#else:
#	print('Не было исключений.')

#Try..Finally
#Представим, что в программе происходит чтение файла и необходимо убедиться, что объект файла был корректно закрыт и что не возникло никакого исключения
#Этого можно достичь с применением блока finally
#
#import time
#
#try:
#	f = open('poem.txt')
#	while True: #наш обычный способ читать файлы
#		line = f.readline()
#		if len(line) == 0:
#			break
#		print(line, end='')
#		time.sleep(2) #Пусть подождет некоторое время
#except KeyboardInterrupt:
#	print('!! Вы отменили чтение файла.')
#finally:
#	f.close()
#	print('(Очистка: Закрытие файла)')

#Оператор with
#Типичной схемой является запрос некоторого ресурса в блоке try с последующим освобождением этого ресурса в блоке finally. Для того, чтобы сделать это более
#"чисто", существует оператор with:
#
#with open("poem.txt") as f:
#	for line in f:
#		print(line, end=' ')






















